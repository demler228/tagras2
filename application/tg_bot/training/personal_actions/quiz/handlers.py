from aiogram import Router, types, F
from aiogram.types import Message, CallbackQuery
from aiogram.enums import ParseMode
from domain.quiz.db_bl import DBService
import random
from application.tg_bot.training.entities.questions import Question
from .keyboards import get_answers_keyboard, get_themes_keyboard
from .callback_factories import QuizCallbackFactory
from utils.data_state import DataSuccess
from application.tg_bot.menu.personal_actions.keyboards.menu_keyboard import get_main_menu_keyboard
from domain.quiz.db_dal import QuizDAL

router = Router()

user_data = {}


@router.callback_query(F.data == "quiz_button")
async def handle_quiz_button(callback_query: types.CallbackQuery):
    themes_result = DBService.get_themes()
    if isinstance(themes_result, DataSuccess):
        themes = themes_result.data
    else:
        await callback_query.message.answer("üö´ –¢–µ–º—ã –¥–ª—è –≤–∏–∫—Ç–æ—Ä–∏–Ω—ã –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
        return

    await callback_query.message.answer(
        "üéØ *–í—ã–±–µ—Ä–∏—Ç–µ —Ç–µ–º—É –¥–ª—è –≤–∏–∫—Ç–æ—Ä–∏–Ω—ã:*",
        reply_markup=get_themes_keyboard(themes),
        parse_mode=ParseMode.MARKDOWN
    )
    await callback_query.answer()


@router.callback_query(QuizCallbackFactory.filter(F.action == "select_theme"))
async def handle_theme_selection(callback_query: CallbackQuery, callback_data: QuizCallbackFactory):
    theme_id = callback_data.theme_id
    user_id = callback_query.from_user.id

    questions_result = DBService.get_questions_by_theme(theme_id)
    if isinstance(questions_result, DataSuccess):
        all_questions = questions_result.data
        questions = random.sample(all_questions, min(10, len(all_questions)))
    else:
        await callback_query.message.answer("üö´ –í–æ–ø—Ä–æ—Å—ã –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Ç–µ–º–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
        return

    if not questions:
        await callback_query.message.answer("üö´ –í–æ–ø—Ä–æ—Å—ã –ø–æ –≤—ã–±—Ä–∞–Ω–Ω–æ–π —Ç–µ–º–µ –Ω–µ –Ω–∞–π–¥–µ–Ω—ã.")
        return

    user_data[user_id] = {
        "step": "quiz_in_progress",
        "questions": questions,
        "current_question": 0,
        "score": 0,
        "message_id": None,
    }

    await send_question(callback_query.message, user_id)
    await callback_query.answer()


@router.callback_query(QuizCallbackFactory.filter(F.action == "answer"))
async def handle_answer_selection(callback_query: CallbackQuery, callback_data: QuizCallbackFactory):
    user_id = callback_query.from_user.id
    user_state = user_data.get(user_id, {})

    if user_state.get("step") != "quiz_in_progress":
        await callback_query.answer("üö´ –í–∏–∫—Ç–æ—Ä–∏–Ω–∞ –Ω–µ –∞–∫—Ç–∏–≤–Ω–∞.")
        return

    selected_answer_index = callback_data.answer_index
    questions = user_state["questions"]
    current_question_index = user_state["current_question"]
    current_question: Question = questions[current_question_index]

    shuffled_answers = user_state["shuffled_answers"][current_question_index]
    selected_answer = shuffled_answers[selected_answer_index]
    correct_answer = current_question.correct_answer

    if selected_answer == correct_answer:
        user_state["score"] += 1
        await callback_query.answer("‚úÖ –í–µ—Ä–Ω–æ!")
    else:
        await callback_query.answer("‚ùå –ù–µ–≤–µ—Ä–Ω–æ!")

    user_state["current_question"] += 1
    if user_state["current_question"] < len(questions):
        await send_question(callback_query.message, user_id)
    else:
        score = user_state["score"]
        theme_id = questions[0].theme_id

        save_result = QuizDAL.save_quiz_result(
            user_id=user_id,
            theme_id=theme_id,
            score=score
        )

        if user_state.get("message_id"):
            try:
                await callback_query.message.bot.delete_message(
                    chat_id=callback_query.message.chat.id,
                    message_id=user_state["message_id"]
                )
            except:
                pass

        is_admin = False

        if isinstance(save_result, DataSuccess):
            result_message = (
                f"üéâ *–í–∏–∫—Ç–æ—Ä–∏–Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!*\n"
                f"‚úÖ –í–∞—à —Å—á–µ—Ç: *{score}* –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤\n"
                f"üìä –†–µ–∑—É–ª—å—Ç–∞—Ç —Å–æ—Ö—Ä–∞–Ω–µ–Ω!\n\n"
                f"–í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–µ–¥—É—é—â–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–∑ –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é"
            )
        else:
            result_message = (
                f"üéâ *–í–∏–∫—Ç–æ—Ä–∏–Ω–∞ –∑–∞–≤–µ—Ä—à–µ–Ω–∞!*\n"
                f"‚úÖ –í–∞—à —Å—á–µ—Ç: *{score}* –ø—Ä–∞–≤–∏–ª—å–Ω—ã—Ö –æ—Ç–≤–µ—Ç–æ–≤\n"
                f"‚ö†Ô∏è –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å —Ä–µ–∑—É–ª—å—Ç–∞—Ç\n\n"
                f"–í—ã–±–µ—Ä–∏—Ç–µ —Å–ª–µ–¥—É—é—â–µ–µ –¥–µ–π—Å—Ç–≤–∏–µ –∏–∑ –≥–ª–∞–≤–Ω–æ–≥–æ –º–µ–Ω—é"
            )

        await callback_query.message.answer(
            result_message,
            parse_mode=ParseMode.MARKDOWN,
            reply_markup=get_main_menu_keyboard(is_admin=is_admin)
        )
        user_data.pop(user_id)


async def send_question(message: Message, user_id: int):
    user_state = user_data[user_id]
    questions = user_state["questions"]
    current_question_index = user_state["current_question"]
    question: Question = questions[current_question_index]

    shuffled_answers = question.answers.copy()
    random.shuffle(shuffled_answers)

    if "shuffled_answers" not in user_state:
        user_state["shuffled_answers"] = [None] * len(questions)
    user_state["shuffled_answers"][current_question_index] = shuffled_answers

    answers_text = "\n".join([f"{i + 1}. {answer}" for i, answer in enumerate(shuffled_answers)])
    question_message = (
        f"‚ùì *–í–æ–ø—Ä–æ—Å {current_question_index + 1}:*\n"
        f"{question.text}\n\n"
        f"*–í–∞—Ä–∏–∞–Ω—Ç—ã –æ—Ç–≤–µ—Ç–æ–≤:*\n"
        f"{answers_text}"
    )

    if user_state.get("message_id"):
        await message.bot.edit_message_text(
            chat_id=message.chat.id,
            message_id=user_state["message_id"],
            text=question_message,
            reply_markup=get_answers_keyboard(
                question_index=current_question_index,
                answers=shuffled_answers
            ),
            parse_mode=ParseMode.MARKDOWN
        )
    else:
        sent_message = await message.answer(
            question_message,
            reply_markup=get_answers_keyboard(
                question_index=current_question_index,
                answers=shuffled_answers
            ),
            parse_mode=ParseMode.MARKDOWN
        )
        user_state["message_id"] = sent_message.message_id